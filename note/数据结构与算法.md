# 数据结构与算法

本质: 数据结构与算法的本质就是 **一门专门研究数据如何组织、存储和操作的科目**。

算法 + 数据结构 = 程序（Algorithm + Data Structures = Programs）

**逻辑思维、代码能力提升离不开对于数据的处理：**

- 所有的编程最终的目的都是为了**处理数据**
- 而数据结构与算法就是一门专门讲解数据应该**如何存储、组织、操作的课程**
- 所以数据结构与算法可以更好的**锻炼我们的逻辑思维能力和代码编程能力**，帮助我们平时在处理一些复杂数据时，可以更好的编写代码，写成高效的代码。
- 因为所有的编程思想都是想通的，只是**换了一种语言来处理数据**而已
- 对于未来更多的领域，比如 **人工智能、区块链、数据结构与算法也是它们的基石**，时必须要掌握的一门课程。

## 一、到底什么是数据结构？

### 1. 什么是数据结构？

数据结构是指组织和管理数据的方式，常见的数据结构有**数组、链表、栈、队列、树、图**等。

- 数据结构就是在计算机中，存储和组织数据的方式
- 我们知道，计算机中数据量非常庞大，如何以高效的方式组织和存储数据？



- 每一种都有其对应的应用场景，**不同的数据结构**的**不同的操作**性能是不同的。

- 有的**查询性能很快**，有的**插入速度很快**，有的是**插入头和尾速度很快**。

- 有的**做范围查找很快**，有的**允许元素重复**，有的**不允许重复**等等。

  

常见的数据结构： **图结构、散列表、树结构、堆结构、数组、栈结构、队列、链表**

### 2. 什么是算法？

算法是指解决问题的方法和步骤，常见的有 **排序算法(快速排序、冒泡排序)、查找算法(如二分查找)、图解发(如最短路径算法)等**。

数据结构与算法是计算机科学的基础

- 在解决问题的过程中，不仅仅**数据的存储方式会影响效率，算法的优劣也会影响着效率。**

**定义**

- 一个有限指令集，每条指令的描述不依赖于语言
- 结束一些输入
- 产生输出
- 一定在有限步骤之后终止

Algorithm这个单词本意就是 **解决问题的办法/步骤逻辑**。

数据结构的实现，离不开算法。

## 二、线性结构

-  线性结构（Linear List） 是由n(n>=0)个数据元素（结点）a[0],...a[n-1]组成的有限序列。





### 1 线性结构 --- 数组 、 栈 、 队列 、链表

#### 1.1 数组（Array）

 **结构是一种重要的数据结构**

- 几乎是每种编程语言都会提供的一种 **原生数据结构**；
- 并且我们**可以借助数组结构来实现其他的数据结构**，比如栈、队列、堆。

**通常数组的内存是连续的，所以数组在知道下标值的情况线，访问效率是非常高的**

![1675421127600](D:\code\code\Structure_Algorithm\截图\1675421127600.jpg)

TypeScript中数组的各种用法。

https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array

####  1.2 栈结构（Stack）

- 栈也是一种非常常见的数据结构，并且在程序中的**应用非常广泛**
- 我们知道数组是一种线性结构，并且可以在数组的任意位置**插入**和**删除数据**。
- 但是有的时候，我们为了实现某些功能，必须对这种任意性加以**限制**。
- 而栈和队列 就是比较常见的受限的线性结构。

####  1.3栈结构示意图：



特点： **后进先出**

- 其限制是仅允许在**表的一端**进行插入 和 删除运算。这一端被称为**栈顶**，相对地，把另一端称为**栈底**。
- LIFO(last in first out)表示就是后进先出，
- 向一个栈插入新的元素又称作 **进栈**、**入栈**或**压栈**，它是把新元素放到栈顶元素上面，使之成为新地栈顶元素。
- 从一个栈删除元素又称作 **出栈或退栈**，它是把栈顶元素删除，使其相邻地元素成为新地栈顶元素。

#### 1.4 栈结构的实现：

基于 **数组** 和 **链表**

栈常见有哪些操作呢？

- push(element): 添加一个新元素到栈顶位置
- pop(): 移除栈顶的元素，同时返回被移除的元素。
- peek(): 返回栈顶元素，不对栈做任何修改
- isEmpty(): 如果栈里没有任何元素就返回true,否则返回false
- size(): 返回栈里的元素个数。和数组的 length属性很类似。



**继承/接口 =》 是多态的前提**

````ts
// 封装一个栈
// 泛型 <T>
import IStack from "./IStack";
// 不传就是 any
// 如果ArrayStack 漏掉的了 IStack 中的 方法就会报错
class ArrayStack<T = any> implements IStack<T> {
  // 定义一个数组/链表，用于存储元素
  //  private 私有的
  private data: T[] = [];

  //  push(element): 添加一个新元素到栈顶位置
  push(element: T): void {
    this.data.push(element);
  }
  //pop(): 移除栈顶的元素，同时返回被移除的元素。
  pop(): T | undefined {
    return this.data.pop();
  }
  // peek(): 返回栈顶元素，不对栈做任何修改
  peek(): T | undefined {
    return this.data[this.data.length - 1];
  }
  // isEmpty(): 如果栈里没有任何元素就返回true,否则返回false
  isEmpty(): boolean {
    return this.data.length === 0;
  }
  // size(): 返回栈里的元素个数。和数组的 length属性很类似
  size(): number {
    return this.data.length;
  }
}

class LinkedStack {}

// 创建Stack 的实例
// 借助工具 ts-node 运行我们的.ts文件 npm install -g ts-node
// 运行 ts-node 加文件名
// 上面的 T 在这里创建实例的时候 就会传人类型
// const stack1 = new ArrayStack<String>();
// stack1.push("aaa");
// stack1.push("bbb");
// stack1.push("ccc");
// stack1.push("ddd");
// const res = stack1.pop();
// console.log(res?.split(" "));
// console.log(stack1.peek());
// console.log(stack1.pop());
// console.log(stack1.pop());
// console.log(stack1.pop());
// console.log(stack1.pop());
// console.log(stack1.isEmpty());
// console.log(stack1.size());
export default ArrayStack;

````

````ts
import ArrayStack from "./02_实现栈结构Stack(重构)";

// 十进制转 二进制   拿十进制的数 /2
function decimalToBinary(decimal: number): string {
  // 1.创建一个栈 用于存放余数
  const stack = new ArrayStack<number>();

  // 2. 这个地方要重复多次 循环
  // while（不确定次数，只知道循环的条件）
  // for(知道次数用这个)
  while (decimal > 0) {
    const result = decimal % 2;
    stack.push(result);
    decimal = Math.floor(decimal / 2); // 去除小数点Math.floor
  }

  // 3. 将所有的余数 都已经存放在 stack,取出来就可以了
  let binary = "";
  while (!stack.isEmpty()) {
    // console.log(stack.pop());
    binary += stack.pop();
  }
  return binary;
}

console.log(decimalToBinary(35));

export {};
````

**封装 接口**

````ts
// IStack.ts
// 定义栈的结构  接口
interface IStack<T> {
  push(element: T): void;
  pop(): T | undefined;
  peek(): T | undefined;
  isEmpty(): boolean;
  size(): number;
}

export default IStack;

````

继承

````ts
import IStack from "./IStack";

class LinkedStack<T> implements IStack<T> {
  push(element: T): void {
    throw new Error("Method not implemented.");
  }
  pop(): T | undefined {
    throw new Error("Method not implemented.");
  }
  peek(): T | undefined {
    throw new Error("Method not implemented.");
  }
  isEmpty(): boolean {
    throw new Error("Method not implemented.");
  }
  size(): number {
    throw new Error("Method not implemented.");
  }
}

function printStack<T>(stack: IStack<T>) {}
// printStack(LinkedStack);
export {};

````

##### 面试题 -> 栈

- 十进制转 二进制 

````ts
import ArrayStack from "./02_实现栈结构Stack(重构)";

// 十进制转 二进制   拿十进制的数 /2
function decimalToBinary(decimal: number): string {
  // 1.创建一个栈 用于存放余数
  const stack = new ArrayStack<number>();

  // 2. 这个地方要重复多次 循环
  // while（不确定次数，只知道循环的条件）
  // for(知道次数用这个)
  while (decimal > 0) {
    const result = decimal % 2;
    stack.push(result);
    decimal = Math.floor(decimal / 2); // 去除小数点Math.floor
  }

  // 3. 将所有的余数 都已经存放在 stack,取出来就可以了
  let binary = "";
  while (!stack.isEmpty()) {
    // console.log(stack.pop());
    binary += stack.pop();
  }
  return binary;
}

console.log(decimalToBinary(35));

export {};
````

- 给定一个只包括'(',')','{','}','[',']'的字符串s,判断字符串是否有效
- 左括号必须用相同类型的右括号闭合
- 左括号必须以正确的顺序闭合
- 每个右括号都有一个对应的相同类型的左括号

````ts
import ArrayStack from "./02_实现栈结构Stack(重构)";

function isValid(s: String): boolean {
  // 1.创建一个栈 用于存放余数
  const stack = new ArrayStack<string>();

  for (let i = 0; i < s.length; i++) {
    const c = s[i];
    switch (c) {
      case "(":
        stack.push(")");
        break;
      case "{":
        stack.push("}");
        break;
      case "[":
        stack.push("]");
        break;
      default:
        if (c !== stack.pop()) return false;
        break;
    }
  }
  return stack.isEmpty();
}
console.log(isValid("({})[]"));
console.log(isValid("({}[]"));
export {};
````

#### 1.5 队列结构（Queue）

队列也是一种受限的线性表，**先进先出**（FIFO First In First Out）

可以基于 **数组 和 链表**

**遍历二叉树**

1. **先序遍历**
2. **中序遍历**
3. **后序遍历**
4. **层序遍历(队列)**

````ts
import IList from "../IList/IList";
// extends 继承 和栈公共的 方法
interface IQueue<T> extends IList<T> {
  // 入队方法
  enqueue(element: T): void;
  // 出队方法
  dequeue(): T | undefined;
  // 返回第一个元素
  // peek(): T | undefined;
  // isEmpty(): boolean;
  // size(): number;

  get sizes(): number;
}
export default IQueue;
````

````ts
import IQueue from "./IQueue";

class ArrayQueue<T> implements IQueue<T> {
  // 内部通过数组（链表）保存
  private data: T[] = [];

  enqueue(element: T): void {
    this.data.push(element);
  }
  dequeue(): T | undefined {
    //shift 移除数组中第一个元素
    return this.data.shift();
  }
  peek(): T | undefined {
    return this.data[0];
  }
  isEmpty(): boolean {
    return this.data.length === 0;
  }
  size(): number {
    return this.data.length;
  }
  get sizes(): number {
    return this.data.length;
  }
}
export default ArrayQueue;
````

##### 面试题 -> 队列

**击鼓传花**是一个常见的面试算法题：**使用队列可以非常方便的实现最终的结果。**



#### 1.6 链表

![16769678668728](D:\code\code\Structure_Algorithm\截图\16769678668728.png)

##### 链表以及数组的缺点

- 链表和数组一样，可以用于存储一系列的元素，但是链表和数组的实现机制完全不同。

- 数组

  - 要存储多个元素，数组（或选择链表）可能是最常见的数据结果。
  - 我们之前说过，几乎每一种编程语言都有默认实现数组结构。

- 但是数组也有很多缺点

  - 数组的创建通常需要申请一段 **连续的内存空间**，并且大小是固定的，所有当当前数组**不能满足容量需求**时，需要扩容。
  - 而且在**数组开头或中间位置插入数据的成本很高**，需要**进行大量元素的位移**。
  - 尽管JAVAScript 的Array底层可以帮我们做这些事，但背后的原理依然是这样。

- 要存储多个元素，另外一个选择就是**链表**。

- 但不同于数组，链表中的元素在内存中**不必是连续的空间**。

  - 链表的每个元素由一个存储**元素本身的节点**和一个指向下一个元素的引用(有些语言称为指针或者链接)组成。

- 相对于数组，链表有一些优点：

  - **内存空间不是必须连续的。**

    1.可以充分利用计算机的内存，实现灵活的内存动态管理。

  - 链表不必在创建时就**确定大小**，并且大小可以**无限的延申**下去。

  - 链表在**插入和删除数据**时，时间复杂度可以达到O(1).

    1.相对数组效率高很多。

- **相对于数组，链表有一些缺点:**

  - 链表访问任何一个位置的元素时，都需要**从头开始访问**。
  - **无法通过下标直接访问元素**，需要从头一个个访问，直到找到对应的元素。

##### 链表封装

**列表里面常见的方法**

- append(value): 向链表尾部添加一个新的项
- insert(position,value); 向链表的特点位置插入一个新的项。
- get(position)； 获取对应位置的元素
- indexOf(value); 返回元素在链表中的索引。如果链表中没有该元素则返回-1
- update(position,value); 修改某个位置的元素；
- removeAt(position); 从链表特定位置移除一项；
- remove(value); 从链表中移除一项；
- isEmpty(value); 如果链表不包含任何元素，返回true,长度大于0返回false
- size(); 返回链表包含元素的个数， length 

接口封装 这些方法

````ts
import ILinkedList from "./ILinkedList";

// 1. 创建Node 节点类
class Node<T> {
  value: T;
  next: Node<T> | null = null;
  constructor(value: T) {
    this.value = value;
    this.next = null;
  }
}

// 2. 创建LinkedList类
class LinkedList<T> implements ILinkedList<T> {
  // head 要指向下一个node 节点
  private head: Node<T> | null = null;
  // 记录几个节点了
  private length: number = 0;

  size() {
    return this.length;
  }
  //
  peek(): T | undefined {
    return this.head?.value;
  }
  // 私有方法
  private getNode(position: number): Node<T> | null {
    let index = 0;
    let current = this.head;
    while (index++ < position && current) {
      current = current.next;
    }
    // 返回的是当前需要的节点1
    return current;
  }
  // 添加节点
  append(value: T) {
    // 1. 根据value 创建一个新节点
    const newNode = new Node(value);

    // 2. 判断是否为第一个 else 给下一节点添加元素
    if (!this.head) {
      this.head = newNode;
    } else {
      let current = this.head;
      while (current.next) {
        current = current.next;
      }
      // current 肯定是指向最后一个节点的
      current.next = newNode;
    }
    this.length++;
  }

  // 遍历列表
  traverse() {
    const values: T[] = [];
    let current = this.head;
    while (current) {
      values.push(current.value);
      current = current.next;
    }
    console.log(values.join("->"));
  }

  // 插入方法
  // 要判断边界值
  insert(value: T, position: number): boolean {
    // 1. 判断越界值
    if (position < 0 || position > this.length) return false;

    // 2. 创建新的节点
    const newNode = new Node(value);

    // 3. 判断是否需要插入到头部
    if (position === 0) {
      // 没有指向的数据 会被回收调
      // 先将自己指向 head 再将 head 指向自己
      newNode.next = this.head;
      this.head = newNode;
    } else {
      // 拿前一个节点
      const previous = this.getNode(position - 1);

      // 拼接后面的节点
      newNode.next = previous?.next ?? null;
      // !断言 一定有值
      previous!.next = newNode;
    }
    this.length++;

    return true;
  }

  // 删除方法：
  removeAt(position: number): T | null {
    // 1. 越界判断
    if (position < 0 || position >= this.length) return null;
    // 2. 删除操作
    // 判断是否要删除第一个节点
    let current = this.head;
    if (position === 0) {
      this.head = current?.next ?? null;
    } else {
      // 重构代码
      // 拿上一个节点
      const previous = this.getNode(position - 1);

      // 找到需要的节点了
      // 跳过 需要删除的节点 秒啊
      current = previous?.next || null;
      previous!.next = previous?.next?.next ?? null;
    }

    this.length--;
    return current?.value ?? null;
  }

  remove(value: T): T | null {
    const index = this.indexOf(value);
    this.length--;
    return this.removeAt(index);
  }

  // get 方法拿到对应元素的值
  get(position: number): T | null {
    // 判断跨域
    if (position < 0 || position >= this.length) return null;

    // 2.查找元素，并且返回元素
    return this.getNode(position)?.value || null;
  }

  // 更新方法
  update(value: T, position: number): boolean {
    if (position < 0 || position >= this.length) return false;
    // 获取对应的节点直接更新 即可
    const currentNode = this.getNode(position); // 获取
    currentNode!.value = value; // 更新
    return true;
  }

  // 根据值 获取对应的索引 indxOf
  indexOf(value: T): number {
    let current = this.head;
    let index = 0;
    while (current) {
      if (current.value === value) {
        return index;
      }
      index++;
      current = current.next;
    }

    return -1;
  }

  // 判断链表是否为空
  isEmpty() {
    return this.length === 0;
  }
}

const linkedList = new LinkedList<string>();
console.log("------------ 测试append ------------");
linkedList.append("aaa");
linkedList.append("bbb");
linkedList.append("ccc");
linkedList.append("ddd");
linkedList.traverse();

console.log("------------ 测试insert ------------");
linkedList.insert("abc", 0);
linkedList.traverse();
linkedList.insert("cba", 2);
linkedList.insert("nba", 6);
linkedList.traverse();

// 测试删除节点
console.log("------------ 测试removeAt ------------");
linkedList.removeAt(0);
linkedList.removeAt(0);
linkedList.traverse();

console.log(linkedList.removeAt(2));
linkedList.traverse();
console.log(linkedList.removeAt(3));
linkedList.traverse();

console.log("------------ 测试get ------------");
console.log(linkedList.get(0));
console.log(linkedList.get(1));
console.log(linkedList.get(2));
// ts-node 04...
console.log("------------ 测试update ------------");
linkedList.update("kkk", 1);
linkedList.update("yyy", 2);
console.log(linkedList.get(1));

console.log("------------ 测试indexOf ------------");
console.log(linkedList.indexOf("kkk"));
console.log(linkedList.indexOf("yyy"));
linkedList.traverse();

console.log("------------ 测试indexOf ------------");
console.log(linkedList.remove("yyy"));
console.log(linkedList.remove("kkk"));
console.log(linkedList.removeAt(0));
linkedList.traverse();
console.log(linkedList.isEmpty());
export {};

````

`````ts
import IList from "../IList/IList";

interface ILinkedList<T> extends IList<T> {
  append(value: T): void;
  traverse(): void;
  insert(value: T, position: number): boolean;
  removeAt(position: number): T | null;
  get(position: number): T | null;
  update(value: T, position: number): boolean;
  indexOf(value: T): number;
  remove(value: T): T | null;
}

export default ILinkedList;


// ../IList/IList
interface IList<T> {
  peek(): T | undefined;
  isEmpty(): boolean;
  size(): number;
}
export default IList;

`````





### 2 什么是算法复杂度？(顺序查找 , 二分查找)

顺序查找的时间复杂度是 O(n)

二分查找的时间复杂度是O(log n)

顺序查找

````ts
/**
 * 顺序查询的方法
 * @param array 查找的数组
 * @param num 查找的元素
 * @returns 查找到的索引，未找到返回-1
 */
function sequentSearch(array: number[], num: number) {
  for (let i = 0; i < array.length; i++) {
    const item = array[i];
    if (item === num) {
      return i;
    }
  }
  return -1;
}
const index = sequentSearch([1, 3, 5, 10, 100, 222, 333], 100);
console.log(index);

export default sequentSearch;
````

二分查找

````ts
/**
 * 顺序查询的方法
 * @param array 查找的数组
 * @param num 查找的元素
 * @returns 查找到的索引，未找到返回-1
 */
function binarySearch(array: number[], num: number) {
  // 1. 先定义左边的索引
  let left = 0;
  // 2. 定义右边的索引
  let right = array.length - 1;

  // 3. 开始查找
  while (left <= right) {
    let mid = Math.floor((left + right) / 2);
    const midNum = array[mid];
    if (midNum === num) {
      return mid;
    } else if (midNum < num) {
      left = mid + 1;
    } else {
      right = mid - 1;
    }
  }
  return -1;
}

const index = binarySearch([1, 3, 5, 10, 100, 222, 333], 100);
console.log(index);
export default binarySearch;
````

测试:  hy-algokit借用了老师提供的 npm库

````ts
import { testOrderSearchEfficiency } from "hy-algokit";
import sequentSearch from "./01_查找算法-顺序查找";
import binarySearch from "./02_查找算法-二分查找";

// const MAX_LENGTH = 10000000;
// const nums = new Array(MAX_LENGTH).fill(0).map((_, index) => index);

// const num = MAX_LENGTH / 2;

// // const start = new Date().getTime();
// const startTime = performance.now();
// // const index = sequentSearch(nums, num); //索引的位置： 5000000 消耗的时间： 9.52759999036789
// const index = binarySearch(nums, num); // 索引的位置： 5000000 消耗的时间： 0.1466999650001526
// const endTime = performance.now();
// console.log("索引的位置：", index, "消耗的时间：", endTime - startTime);

testOrderSearchEfficiency(sequentSearch); // 数组长度:10000000 - sequentSearch 消耗时间: 11.349200010299683

testOrderSearchEfficiency(binarySearch); // 数组长度:10000000 - binarySearch 消耗时间: 0.033600032329559326
export {};
````

#### 2.1 大O表示法 （Big O notation）--> 兰道符号

![image-20230619105035575](D:\code\code\Structure_Algorithm\截图\image-20230619105035575.png)

| 符号       | 名称                             |
| ---------- | -------------------------------- |
| O(1)       | 常数 阶                          |
| O(log n)   | 对数 阶                          |
| O(n)       | 线性、次线性                     |
| O(n log n) | 线性对数、对线性、拟线性、超线性 |
| O(n²)      | 平方                             |

#### 2.2 空间复杂度

空间复杂度的计算方法与时间复杂度类似，通常需要分析程序中需要额外分配的内存空间，如数组、变量、对象、递归调用等。

- **当空间复杂度很大时，可能会导致内存不足，程序崩溃。**

![image-20230619150654752](D:\code\code\Structure_Algorithm\截图\image-20230619150654752.png)

- 如果数据量不大，且需要频繁随机访问元素，使用数组可能会更好。
- 如果数据量大，或者需要频繁插入和删除元素，使用链表可能会更好。

### 3 哈希表 HashTable

- 哈希表通常是基于**数组**进行实现的，但是相对于数组，它也很多的优势：
  - 它可以提供非常快速的 **插入-删除-查找操作**；
  - 哈希表的速度比数还要快，基本可以瞬间查找到想要的元素；
  - 哈希表的速度比树还要块；
  - 哈希表相对于树来说编码要容易很多；
  
- 哈希表相对于数组的一些不足；
  - 哈希表中的数据是**没有顺序**的，所以不能以一种固定的方式（比如从小到大）来遍历其中的元素（没有特殊处理情况下）；
  - 通常情况下，哈希表中的key 是**不允许重复**的，不能放置相同的key，用于保存不同的元素

- 哈希表到底是什么呢？
  - **它的结构就是数组**，但是它神奇的地方在于对数组**下标值的一种变换**，这种变换我们可以使用**哈希函数**，通过哈希函数可以获取到 **HashCode**.







#### 3.1 压缩算法

- 现在需要一种**压缩方法**，把幂的连乘方案系统得到的**巨大整数范围**压缩到**可接收的数组范围中**。

- cats => 幂的连乘 => 大的数字 => 哈希化 => 索引值

- 解决重复或者冲突
  - **链地址法** 用的最多
  - ![image-20230619174509422](D:\code\code\Structure_Algorithm\截图\image-20230619174509422.png)
  - **开放地址法**
    - 主要的工作方式是 **寻找空白的单元格**来添加重复的数据。
    - 线性探测  2 + 1 + 1 步长为一
    - 二次探测 2+ 1 + 4 + 9 
    - 再哈希法  stepSize = constart - (key % constart )
  
- 装填因子
  - 个数 / 容量  = 装填因子； 总数据项 / 哈希表长度 = 装填因子
  - 当装填因子 大于0.75时需要对数据进行一个扩容 一般是*2
  
- 好的哈希函数应该尽可能让计算的过程变得简单，提高计算的效率

  - 哈希函数最主要的两个操作是： 幂的连乘    取余

  - 哈希表的主要 **优点是它的速度**，所以在速度上不能满足，那么就达不到设计的目的了。
  - 提高速度的一个办法就是让哈希函数中<font color="#D43725">**尽量少的有乘法和除法**</font>，因为它们的<font color="#D43725">**性能是比较**</font>低的。
  - <font color="#D43725">快速的计算</font> -- <font color="#D43725">均匀的分布</font>
  - <font color="#D43725">霍纳法则  -》 提取公因式</font>

#### 3.2 实现哈希表

- 为什么需要 扩容？
- 随着**数据量的增多**，每一个index对应的bucket 会·越来越长，也就造成**效率的降低**。所以需要**扩容**
  - 数组**长度 * 2**
  - 对原来哈希表中的**数据再次哈希化**，放入到正确的位置上
  -  length 为质数能让分配更加的均匀
  - 质数的特点： <font color="#D43725">大于一的自然数中，只能被1和自身整除的数</font>

````ts
// import hashFunc from "./01_哈希函数hashFunc";

class HashTable<T = any> {
  // 创建数组 -》 存放连地址法中的链(数组)
  // key value
  storage: [string, T][][] = []; // [[[key,value]]]
  // 定义数组的长度
  private length: number = 7;
  // 记录已经存放元素的个数
  private count: number = 0;

  // 哈希函数
  private getIndex(key: string, max: number) {
    let hashCode = 0;
    const length = key.length;
    for (let i = 0; i < length; i++) {
      // 霍纳法则  计算hashCode
      // charCodeAt 输出72，因为'H'的Unicode编码是72
      hashCode = 31 * hashCode + key.charCodeAt(i);
    }
    // 2. 求出索引值
    const index = hashCode % max;
    return index;
  }

  // 判断是否为质数
  isPrime(num: number): boolean {
    // 大于一的自然数中，只能被1和自身整除的数
    // num = 8
    // 2 ~ 7
    // 11 是否为质数
    // 平方根 3.xxx

    const sqrt = Math.sqrt(num);
    for (let i = 2; i <= sqrt; i++) {
      if (num % i === 0) {
        return false;
      }
    }
    // 2 `~ 7 都被遍历后 没有返回的就是质数
    return true;
  }

  private getNextPrime(num: number) {
    // 确定 newLength 是否为质数
    let newPrime = num;
    while (!this.isPrime(newPrime)) {
      newPrime++;
    }
    return newPrime;
  }

  // 扩容 缩容
  private resize(newLength: number) {
    // 1. 设置新的长度
    // 确定 newLength 是否为质数
    let newPrime = this.getNextPrime(newLength);
    if (newPrime < 7) newPrime = 7;
    this.length = newPrime;
    console.log("length", this.length);
    // 2. 获取原来所有的数据，存放到新的容量数组中
    // 2.1 对数据进行初始化
    const oldStorage = this.storage;
    this.storage = [];
    this.count = 0;
    // 2.2 获取原来数据，放入新的数组中
    oldStorage.forEach((bucket) => {
      if (!bucket) return;
      for (let i = 0; i < bucket.length; i++) {
        const tuple = bucket[i];
        this.put(tuple[0], tuple[1]);
      }
    });
  }


  // 插入 / 修改
  put(key: string, value: T) {
    // 1. 根据key 获取数组中索引值
    // hashFunc(key, this.length);
    const index = this.getIndex(key, this.length);
    // 2. 取出索引值对应位置的数组
    let bucket = this.storage[index];
    // 3. 判断bucket 是否有值
    if (!bucket) {
      bucket = [];
      // 重新指向新的地址
      this.storage[index] = bucket;
    }
    // 4. 确定是一个数组了，是否存在对应的key
    let isUpdate = false;
    for (let i = 0; bucket.length > i; i++) {
      const tuple = bucket[i]; // [key,value]
      const tupleKey = tuple[0];
      if (tupleKey === key) {
        // 存在就覆盖
        tuple[1] = value;
        isUpdate = true;
      }
    }
    // 5. 如果没有覆盖 就添加
    if (!isUpdate) {
      bucket.push([key, value]);
      this.count++;
      // 发现 loadFactor 比例已经大于0.75，那么进行扩容
      const loadFactor = this.count / this.length;
      if (loadFactor > 0.75) {
        // 这样重复率很高 需要进行判单寻找到最近的质数
        this.resize(this.length * 2);
      }
    }
  }

  // 获取值
  get(key: string): T | undefined {
    // 1. 根据key 获取
    const index = this.getIndex(key, this.length);

    // 2. 取出索引值对应位置的数组 桶
    let bucket = this.storage[index];
    // console.log("bucket", bucket, this.storage, this.count);

    // 3. 没有值直接return
    if (!bucket) return undefined;

    // 4. 遍历桶
    for (let i = 0; bucket.length > 0; i++) {
      const tuple = bucket[i];
      const tupleKey = tuple[0];
      if (tupleKey === key) {
        return tuple[1];
      }
    }
    return undefined;
  }

  // 删除 remove
  delete(key: string): T | undefined {
    // 1. 获取索引
    const index = this.getIndex(key, this.length);

    // 2. 获取桶
    let bucket = this.storage[index];
    if (!bucket) return undefined;

    // 3. 遍历桶 找数据
    for (let i = 0; i < bucket.length; i++) {
      const tuple = bucket[i];
      const tupleKey = tuple[0];
      if (tupleKey === key) {
        bucket.splice(i, 1);
        this.count--;
        // 如果loadFactor 小于 0.25
        const loadFactor = this.count / this.length;
        if (loadFactor < 0.25 && this.length > 7) {
          this.resize(Math.floor(this.length / 2));
        }
        return tuple[1];
      }
    }
    return undefined;
  }
}
const hashTable = new HashTable();
hashTable.put("aaa", 100);
hashTable.put("aaa", 200);
hashTable.put("bbb", 200);
hashTable.put("hhh", 333);
hashTable.put("fff", 444);
hashTable.put("ccc", 300);
console.log(hashTable.storage);
hashTable.put("ddd", 400);
hashTable.put("eee", 500);
hashTable.put("fff", 600);
hashTable.put("ggg", 700);
console.log(hashTable.storage
// length: 7
// count: 8
// loadFactor:8/ 7 = 1.1xxxx  装填因子 > 0.75 就想要扩容
export default HashTable;

````



## 三、二叉树

**树(Tree): n(n>=0)个节点构成的有限集合。**

n=0,称为空树。

树的术语：

1. **节点的度 Degree**: 节点的**子树个数**。
2. **树的度 Degree**: 树的**高度 (层级)**
   - 完全二叉树：对于一个包含n个节点的完全二叉树，它的高度为log2(n+1)向下取整。完全二叉树的高度较小
3. **叶节点 Leaf  度为0的节点**
4. **父节点 Parent** ： 有子树的节点是其子树的根节点的父节点
5. **子节点 Child**： 若A节点是B节点的父节点，则称B节点是A节点的子节点，子节点也称为孩子节点。
6. **兄弟节点 Sibling**; 具有同一父节点的各节点彼此是为兄弟节点
7. **路径和路径长度**： 从节点n1 到 nk 的路劲为一个节点序列n1 , n2 .... nk;
   - ni 是 n(i+1)的父节点
   - <font color="#D43725">路径所包含 边 的个数为路径的长度</font>
8. **节点层次 Level**，规定根节点在1层，其它任一节点的层数是其父节点的层数加1
9. **树的深度 Depth**: 树中所有节点的**最大层次**是这颗树的深度, 对于任意节点n,n的深度为从根到n的唯一路径长，根的深度为0 
10. 树的高度 Height： 对于任意节点n,n的高度为从n到一片树叶的最长路劲长，所有树叶的高度为0；
11. ![image-20231127172209270](D:\code\code\Structure_Algorithm\截图\image-20231127172209270.png)



### 1. 二叉搜索树类的封装

- 如果一颗树中每个节点**最多只有两个子节点**，这样的树就成为“**二叉树**”。
- 二叉树**可以为空**，也就是**没有节点**。
- 若**不为空**，则它是**由根节点** 和 称为其 **左子树 TL** 和 **右子树 TR** 的两个不相交的二叉树组成。

##### 特性:

- 一颗二叉树 第i**层的最大节点数** 为： 2^(i-1), i>=1;
- 深度 为k**的二叉树有最大节点总数** 为： 2^k - 1， k >= 1;
- 对任何非空二叉树 T， 若n0表示叶节点的个数，n2 是度为2的非叶节点个数，那么两者满足关系n0 = n2 + 1.

##### 完美二叉树（Perfect Binary Tree）

- 在二叉树中，除了**最下一层的叶节点外**，**每层节点都有2个子节点**，就构成了**满二叉树**。

##### 完全二叉树 （Complete Binary Tree）

- 除**二叉树最后一层外，其他各层的节点数走达到最大个数。**
- 且**最后一层从左向右的节点连续存在，只缺右侧若干节点。**
- **最后一层的节点可以从左到右依次缺少若干个，但不能出现断层。也就是说，最后一层的节点应该连续地排列在左边。**
- **完美二叉树**是**特殊的完全二叉树。**
- **堆的本质就是一颗完全二叉树**

##### 二叉搜索树（BST, Binary Search Tree）

- 二叉搜索树, **也称二叉排序树或二叉查找树**
- **二叉搜索树是一颗二叉树，可以为空。**
- **如果不为空，满足以下性质**：
  - 非空左子树的所有键值小于其跟节点的键值。
  - 非空右子树的所有键值大于其根节点的键值。
  - 左、右子树本身也都是二叉搜索树。
- 查找所需的最大次数 等于 二叉搜索树的深度；

````ts
class Node<T> {
  value: T;
  constructor(value: T) {
    this.value = value;
  }
}

export default Node;



import Node from "../IList/Node";
import { btPrint } from "hy-algokit"; // Binary Tree Print 打印二叉树
// 类的继承
class TreeNode<T> extends Node<T> {
  left: TreeNode<T> | null = null;
  right: TreeNode<T> | null = null;
}

class BSTree<T> {
  private root: TreeNode<T> | null = null;
}

export {};

````

##### 二叉树操作汇总

- 插入操作
  - **insert(value)**: 向树中插入一个新的数据。
- 查找操作
  - **search(value)** 在树中查找一个数据，如果节点存在，则返回true,
  - **min**： 返回树中最小的值/数据。
  - **max**:  返回树中最大的值/ 数据。
- 遍历操作
  - **inOrderTraverse**: 通过中序遍历的方式遍历所有的节点。
  - **preOrderTraverse**: 通过先序遍历方式遍历所有节点。
  - **postOrderTraverse**: 通过后序遍历方式遍历所有节点。
  - **levelOrderTraverse** 通过层序遍历方式遍历所有节点。
- 删除操作 （有点复杂）
  - **remove(value )**: 从树中移除某个数据。



### 2. 二叉搜索树插入操作

- **insert(value)**: 向树中插入一个新的数据。

````ts
import Node from "../IList/Node";
import { btPrint } from "hy-algokit"; // Binary Tree Print 打印二叉树
// 类的继承
class TreeNode<T> extends Node<T> {
  left: TreeNode<T> | null = null;
  right: TreeNode<T> | null = null;
}
class BSTree<T> {
  private root: TreeNode<T> | null = null;
  print() {
    btPrint(this.root);
  }
  /** 插入数据的操作 */
  insert(value: T) {
    // 1. 根据传入的value 创建一个 node(TreeNode) 节点
    const newNode = new TreeNode(value);
    // 2. 判断当前是否有了根节点
    if (!this.root) {
      this.root = newNode;
    } else {
      // 树里面有其他值的时候
      this.insertNode(this.root, newNode);
    }
  }
  // 递归
  private insertNode(node: TreeNode<T>, newNode: TreeNode<T>) {
    // 小左 大右
    if (newNode.value < node.value) {
      // 去左边查找空白位置
      if (node.left === null) {
        node.left = newNode;
      } else {
        this.insertNode(node.left, newNode);
      }
    } else {
      // 去右边查找空白位置
      if (node.right === null) {
        node.right = newNode;
      } else {
        this.insertNode(node.right, newNode);
      }
    }
  }
}
const bst = new BSTree<number>();
bst.insert(11);
bst.insert(7);
bst.insert(15);
bst.insert(5);
bst.insert(3);
bst.insert(9);
bst.insert(8);
bst.insert(10);
bst.insert(13);
bst.insert(12);
bst.insert(14);
bst.insert(20);
bst.insert(18);
bst.insert(25);
bst.insert(6);
bst.print();
export {};
````











### 3. 先序遍历、中序遍历

插入数据：11 - 7 - 15 - 5 - 3 - 9 - 8 - 10 -13 - 12 - 14  - 20 - 18  - 25  - 6

- **inOrderTraverse**: 通过中序遍历的方式遍历所有的节点。
  - 先访问左子树
  - 根节点（重要）
  - 后访问右子树
  - 3 - 5 - 7 - 8 - 9 - 10  - 11 - 12 - 13 -14 - 15 - 18 - 20 - 25
  - ![image-20231130142839065](D:\code\code\Structure_Algorithm\截图\image-20231130142839065.png)
  - ````ts
    //中序遍历
      inOrderTraverse() {
        this.inOrderTraverseNode(this.root);
      }
    
      private inOrderTraverseNode(node: TreeNode<T> | null) {
        // 判断是否有值
        if (node) {
          this.inOrderTraverseNode(node.left); // 先访问 左子树
          console.log(node.value); // 根节点
          this.inOrderTraverseNode(node.right); // 右子树
        }
      }
    ````
  - 
- **preOrderTraverse**: 通过先序遍历方式遍历所有节点。
  - 在所有的树结构中（包括子树中），优先访问根节点
  
  - 之后访问左子树
  - 之后访问右子树
  - 11 - 7 - 5 - 3 - 9 - 8 - 10 - 15 -13 - 12 - 14 - 20 - 18 - 25
  - ````ts
    preOrderTraverse() {
        this.preOrderTraverseNode(this.root);
      }
      private preOrderTraverseNode(node: TreeNode<T> | null) {
        if (node) {
          console.log(node.value);
          this.preOrderTraverseNode(node.left);
          this.preOrderTraverseNode(node.right);
        }
      }
    }
    ````
  - 









### 4. 后序遍历、层序遍历

- **postOrderTraverse**: 通过后序遍历方式遍历所有节点。

  - 3 - 5 - 8 -10 - 9 - <font color="red">7</font> - 12 - 14 -13 -18 - 25 - 20 - <font color="red">15</font> - <font color="red">11 </font>

  - ````ts
    postOrderTraverse() {
        this.postOrderTraverseNode(this.root);
      }
    
    private postOrderTraverseNode(node: TreeNode<T> | null) {
       if (node) {
          this.postOrderTraverseNode(node.left);
          this.postOrderTraverseNode(noded.right);
          console.log(node.value);
        }
     }
    ````

  - 

- **levelOrderTraverse** 通过层序遍历方式遍历所有节点。

  - 一层一层

  - 11 - 7 - 15 - 5 - 9 - 13 - 20 - 3 - 8 - 10 - 12 - 14 - 18 - 25
  
  - ````ts
    // 层序遍历
      levelOrderTraverse() {
        // 用队列来处理
        // 伪代码：
        // 1. 访问队列中的出队元素 * 11 出队，并且访问
        // 2. 将出队的节点的左子节点和右子节点分别加入队列
    
        // 1. 没有根节点直接return
        if (!this.root) return;
        // 2. 创建队列结构
        const queue: TreeNode<T>[] = [];
        // 第一个节点根节点
        queue.push(this.root);
        //3. 遍历队列中所有的节点 依次出队
        while (queue.length) {
          // 3.1 访问节点的过程
          const current = queue.shift()!;
          console.log(current.value);
    
          // 3.2 将左子节点放入到队列中
          if (current.left) {
            queue.push(current.left);
          }
    
          //3.3 将右子节点放入队列中
          if (current.right) {
            queue.push(current.right);
          }
        }
      }
    ````
  
    



### 5. 二叉搜索树搜索操作

- **search(value)** 在树中查找一个数据，如果节点存在，则返回true,

  - 判断拿到的节点是否是搜索的节点 

  - 如果不是 搜索的节点比当前节点的值要大，从右边找  小就左边找

  - ````ts
     search(value: T): boolean {
        let current = this.root;
        while (current) {
          // 找到了节点
          if (current.value === value) return true;
      
          if (current.value < value) {
            current = current.right;
          } else {
            current = current.left;
          }
        }
        return false;
      }
      searchL(value: T): boolean {
        return this.searchNode(this.root, value);
      }
      
      private searchNode(node: TreeNode<T> | null, value: T): boolean {
        // 1,如果节点为null 直接返回
        if (node === null) return false;
      
        // 2. 判断node 节点的value 和传入的value比较大小
        if (node.value > value) {
          // 左边查找
          return this.searchNode(node.left, value);
        } else if (node.value < value) {
          // 右边查找
          return this.searchNode(node.right, value);
        } else {
          return true;
        }
      }
    ````

  - 

- **min**： 返回树中最小的值/数据。

  - 一直往左找

  - ```ts
    getMinValue(): T | null {
        let current = this.root;
        while (current && current.left) {
          current = current.left;
        }
        return current?.value ?? null;
      }
    ```

  - 

- **max**:  返回树中最大的值/ 数据。

  - 一直往右找

  - ```ts
    getMaxValue(): T | null {
        let current = this.root;
        while (current && current.right) {
          current = current.right;
        }
        return current?.value ?? null;
      }
    ```

  - 











### 6. 二叉搜索树删除操作

- **remove(value ):** 从树中移除某个数据。

  - 该节点是叶节点（没有子节点，比较简单）

  - 该节点有一个子节点（也相对简单）

  - **该节点右有两个子节点**（情况比较复杂）

    - 去左边找一个比current 节点小的节点，但是是我左子树中最大的节点 --- 找到的节点称为**前驱节点**
    - 去右边找一个比current 节点大的节点，但是是我右子树最小的节点 -- **后继节点**
    - 规律： 最接近current 节点的节点
  
  - 搜索节点
  
  - ````ts
    remove(value: T): boolean {
        //1. 先去搜索是否有这个值
        const current = this.searchNode(value);
        if (!current) return false;
    
        // 2. 获取到三个东西： 当前节点/ 父节点/ 是属于父节点的左子节点，还是右子节点
        let replaceNode: TreeNode<T> | null = null; // 拿到要替换的节点
        if (current.left === null && current.right === null) {
          // 2. 如果删除的是叶子节点  没有子节点'
          replaceNode = null;
        } else if (current.right === null) {
          // 3. 只有一个子节点： 只有左子节点
          replaceNode = current.left;
        } else if (current.left === null) {
          // 4. 只有一个子节点： 只有左子节点
          replaceNode = current.right;
        } else {
          // 5. 有两个子节点
          const cuccessor = this.getSuccessor(current); // 后继节点
          replaceNode = cuccessor;
        }
    
        if (current === this.root) {
          this.root = replaceNode;
        } else if (current.isLeft) {
          current.parent!.left = replaceNode;
        } else {
          current.parent!.right = replaceNode;
        }
    
        return true;
      }
    }
    ````
    
  - ````ts
    private insertNode(node: TreeNode<T>, newNode: TreeNode<T>) {
        // 小左 大右
        if (newNode.value < node.value) {
          // 去左边查找空白位置
          if (node.left === null) {
            node.left = newNode;
          } else {
            this.insertNode(node.left, newNode);
          }
        } else {
          // 去右边查找空白位置
          if (node.right === null) {
            node.right = newNode;
          } else {
            this.insertNode(node.right, newNode);
          }
        }
      }
    ````
  
  - ````ts
     /** 删除*/
      // 后继节点
      private getSuccessor(delNode: TreeNode<T>): TreeNode<T> {
        // 获取右子树
        let current = delNode.right;
        let successor: TreeNode<T> | null = null;
        while (current) {
          successor = current;
          current = current.left;
          if (current) {
            current.parent = successor;
          }
        }
        // 找到后继节点
        console.log("删除节点：", delNode.value, "后继节点：", successor?.value);
        if (successor !== delNode.right) {
          successor!.parent!.left = successor!.right ?? null;
          successor!.right = delNode.right;
        }
        // 一定要进行的操作: 将删除节点的left, 赋值给successor.left
        successor!.left = delNode.left;
        return successor!;
      }
    ````
  
  - 





### 7. 二叉搜索树的缺陷

1. 优势

   - 可以快速地找到给定关键字地数据项 并且可以快速地插入和删除数据项。

2. 问题

   - 如果插入地数据时**有序的数据** 9 8 12 7 6 5 4 3

3. 非平衡树

   - 比较号的二叉搜索树数据应该是左右分布均匀的
   - 但是插入**连续数据**后，**分布不均匀**，我称这种树为 非平衡树，
   - 对于一颗平衡二叉树来说，插入/查找等操作的效率是 **O(logN)**
   - 对于一颗非平衡二叉树，相当于编写了一个链表，查找效率变成了**O(N)**

4. 平衡树

   - AVL树 **整体效率不如红黑树**

   - 红黑树 也通过 **一些特**性来保持树的平衡。一般用他

     

     

## 四、图结构

图的抽象数据类型 - 一些算法的实现。

### 什么是图？

- 图结构是一种与 **树结构**有些相似的数据结果
- 图论是数学的一个分支，并且在数学的概念上，树是图的一种
- 它以图为研究对象，研究顶点 和 边组成的图形的数学理论和方法
- 主要研究的目的是 **事物之间的关系**，**顶点**代表**事物**，**边**代表两个事物的**关系**

### 术语

- 顶点
- 边 --  邻接矩阵
  - ![image-20240624155034832](D:\code\code\Structure_Algorithm\截图\image-20240624155034832.png)
  - ![image-20240624155240698](D:\code\code\Structure_Algorithm\截图\image-20240624155240698.png)
- 相邻顶点
- 度 - 相邻顶点的数量
- 路径
- 无向图
- 有向图
- 无权图
- 带权图

### 图结构的封装与遍历

- 图遍历
  - **广度优先搜索 BFS** 队列
  - **深度优先搜索 DFS** 栈 或  递归
  - 需要明确指点 **第一个被访问的顶点**

````ts
class Graph<T> {
  private verteces: T[] = []; // 顶点
  private adjList: Map<T, T[]> = new Map(); // 边： 邻接表

  /**
   * 添加顶点和边的方法
   * @param vertex
   */
  addVertex(vertex: T) {
    // 将顶点添加到数组中保存
    this.verteces.push(vertex);
    // 创建一个 邻接表中的数组
    this.adjList.set(vertex, []);
  }

  /**
   * 添加边
   * @param v1 顶点1
   * @param v2 顶点2
   */
  addEdge(v1: T, v2: T) {
    this.adjList.get(v1)?.push(v2);
    this.adjList.get(v2)?.push(v1);
  }
  /**
   * 遍历图
   */
  traverse() {
    console.log("Graph:");
    this.verteces.forEach((vartex) => {
      const edges = this.adjList.get(vartex);
      console.log(`${vartex} -> ${edges?.join(" ")}`);
    });
  }
}

const graph = new Graph();
// ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K"].map((vertex) => {
//   graph.addVertex(vertex);
// });
// 添加A-I的顶点
for (let i = 65; i < 74; i++) {
  graph.addVertex(String.fromCharCode(i));
}

graph.addEdge("A", "B");
graph.addEdge("A", "C");
graph.addEdge("A", "D");
graph.addEdge("C", "D");
graph.addEdge("C", "G");
graph.addEdge("D", "G");
graph.addEdge("D", "H");
graph.addEdge("B", "E");
graph.addEdge("B", "F");
graph.addEdge("E", "I");

graph.traverse();

export {};

````



#### 广度优先遍历

````ts
  /**
   * 广度优先
   */
  bfs() {
    // 1. 判断是否有顶点
    if (this.verteces.length === 0) return;

    // 2. 创建队列结婚访问每一个顶点
    const queue: T[] = [];
    queue.push(this.verteces[0]);

    // 3. 创建Set 结构，记录某一个顶点是否被访问
    const visited = new Set<T>();
    visited.add(this.verteces[0]);

    // 4. 遍历队列中的每个顶点
    while (queue.length) {
      // 访问队列中第一个顶点
      const vertex = queue.shift()!;
      console.log(vertex);

      // 相邻的顶点
      const neighbors = this.adjList.get(vertex);
      // 没有值直接跳过当前循环
      if (!neighbors) continue;
      for (const nei of neighbors) {
        // 判断有没有被访问过
        if (!visited.has(nei)) {
          visited.add(nei);
          queue.push(nei);
        }
      }
    }
  }
````

#### 深度优先遍历

````ts
/**
   * 深度优先
   */
  dfs() {
    //1. 判断是否有顶点
    if (this.verteces.length === 0) return;

    // 2. 创建栈结果
    const stack: T[] = [];
    stack.push(this.verteces[0]);

    // 3.创建Set结构
    const visited = new Set<T>();
    visited.add(this.verteces[0]);

    // 4. 从第一个顶点开始访问
    while (stack.length) {
      const vertex = stack.pop()!;
      console.log(vertex);

      const neighbors = this.adjList.get(vertex);
      if (!neighbors) continue;
      for (let i = neighbors.length - 1; i >= 0; i--) {
        const nei = neighbors[i];
        if (!visited.has(nei)) {
          visited.add(nei);
          stack.push(nei);
        }
      }
    }
  }
````



# 高阶

## 一 循环链表 - 双向链表

#### 对象比较处理	

对象里面的类实现一个valueOf

````ts
class Person {
  name: string;
  age: number;

  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
  // *** 特殊处理 告诉js 要比较的对象
  valueOf() {
    return this.age;
  }
}

// 创建Person
const p1 = new Person("why", 18);
const p2 = new Person("kong", 31);
const p3 = new Person("james", 26);
const p4 = new Person("xiaohua", 26);

// 默认情况下 对象是不能进行比较的
console.log(p1 < p2); // true
console.log(p3 > p2); // false
console.log(p3 == p4); // == false  === false
````



### 1. 认识循环链表

循环链表一种特殊的链表结果

- 在普通链表的基础上，最后一个节点的下一个节点不再是null,而是指向链表的第一个节点
- 这样形成了一个环，使得链表能够被无限遍历
- 这样，我们就可以在单向循环链表中 **从任意一个节点出发，不断地遍历下一个节点，直到回到起点。**

实现方式

- 从零去实现一个新的链表，包括其中所有的属性和方法；

- 继承之前封装的LinkeList,只实现差异化的部分；

- ````ts
  // protected 外界还是不能访问我得，但是子类可以访问
  protected head: Node<T> | null = null;
  ````

- ````ts
  // 重构列表支持循环链表
  class CircularLinkedList<T> extends LinkedList<T> {
    append(value: T) {
      // 去调用父类的append方法
      super.append(value);
      // 拿到最后的节点next指向第一个节点
      this.tail!.next = this.head;
    }
  
    insert(value: T, position: number): boolean {
      const isSuccess = super.insert(value, position);
      // 如果是最后一个节点 或者 第一个节点
      if (isSuccess && (position === this.length - 1 || position === 0)) {
        this.tail!.next = this.head;
      }
      return isSuccess;
    }
  
    removeAt(position: number): T | null {
      const value = super.removeAt(position);
      if (value && this.tail && (position === 0 || position === this.length)) {
        this.tail.next = this.head;
      }
      return value;
    }
  
    // traverse(): void {}
  }
  ````

- 





### 2. 认识双向链表

- 既可以 **从头遍历到尾**，又可以**从尾遍历到头**
- 也就是链表相连的过程是 **双向**的.
- 一个节点既有**向前连接的引用prev** , 也有一个**向后连接的引用next.**

缺点

- 每次在插入或删除某个节点时，引用更多
- 相对于单向链表内存空间更大一些
- 



























































